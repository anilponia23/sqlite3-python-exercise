
-- sql/queries.sql
-- ===========================================
-- Task 2 Queries: Manufacturing Data Platform
-- ===========================================

-- 1) Product output by month
-- For a given month (YYYY-MM), per product:
-- - Total good quantity produced
-- - Total scrap quantity
-- - Number of work orders involved
-- We consider operations whose op_start falls in that month.
-- Parameters:
--   :month_prefix -> e.g., '2025-12' (we’ll bind '2025-12%')
-- Note: SQLite LIKE on timestamp strings
-- -------------------------------------------
-- Example skeleton (will be executed from Python with WHERE o.op_start LIKE ?):
-- SELECT p.name AS product_name,
--        COALESCE(SUM(o.good_qty),0)  AS good_qty,
--        COALESCE(SUM(o.scrap_qty),0) AS scrap_qty,
--        COUNT(DISTINCT o.work_order_id) AS num_orders
-- FROM products p
-- LEFT JOIN work_orders w ON w.product_id = p.id
-- LEFT JOIN operations o   ON o.work_order_id = w.id
-- WHERE o.op_start LIKE ?
-- GROUP BY p.name
-- ORDER BY p.name;

-- 2) Current work-in-progress
-- Definition: status='in_progress' OR (now BETWEEN planned_start AND planned_end AND status NOT IN ('completed','cancelled')).
-- Parameters:
--   :now_iso -> e.g., '2025-12-09T12:00:00Z'
-- -------------------------------------------
-- SELECT w.id, p.name AS product, w.planned_qty, w.status, w.planned_start, w.planned_end, w.machine_id
-- FROM work_orders w
-- JOIN products p ON p.id = w.product_id
-- WHERE w.status = 'in_progress'
--    OR ( ? >= w.planned_start AND ? <= w.planned_end
--         AND w.status NOT IN ('completed','cancelled') )
-- ORDER BY w.planned_start;

-- 3) Machine utilization (SQL-only simple metric)
-- For a given date range:
--   utilization = runtime_hours / total_hours_in_range
-- runtime_hours computed as sum(op_end - op_start)
-- Note: We approximate by counting only operations fully inside the range.
-- Parameters:
--   :start_iso, :end_iso
-- -------------------------------------------
-- SELECT
--   m.id AS machine_id,
--   m.name AS machine_name,
--   SUM(
--     (strftime('%s', o.op_end) - strftime('%s', o.op_start)) / 3600.0
--   ) AS runtime_hours
-- FROM machines m
-- LEFT JOIN operations o
--   ON o.machine_id = m.id
--  AND o.op_start >= ?
--  AND o.op_end   <= ?
-- GROUP BY m.id, m.name
-- ORDER BY m.id;

-- 4) Work orders with no production yet
-- List WOs that are released/scheduled (i.e., status IN ('released','planned','delayed','in_progress'))
-- but have no operations.
-- -------------------------------------------
-- SELECT w.id, p.name AS product, w.status, w.planned_start, w.planned_end, w.planned_qty
-- FROM work_orders w
-- JOIN products p ON p.id = w.product_id
-- LEFT JOIN operations o ON o.work_order_id = w.id
-- WHERE w.status IN ('released','planned','delayed','in_progress')
--   AND o.id IS NULL
-- ORDER BY w.planned_start;

-- 5) Top defect / scrap drivers
-- For a given date range, show which product or machine has highest scrap quantity,
-- and the scrap rate = scrap / (good + scrap).
-- We’ll provide two variants:
--   A) by product
--   B) by machine
-- Parameters:
--   :start_iso, :end_iso
-- -------------------------------------------
-- A) By product
-- SELECT p.name AS product_name,
--        COALESCE(SUM(o.scrap_qty),0) AS scrap_qty,
--        COALESCE(SUM(o.good_qty + o.scrap_qty),0) AS total_qty,
--        CASE
--          WHEN COALESCE(SUM(o.good_qty + o.scrap_qty),0) = 0 THEN 0.0
--          ELSE CAST(SUM(o.scrap_qty) AS REAL) / SUM(o.good_qty + o.scrap_qty)
--        END AS scrap_rate
-- FROM products p
-- JOIN work_orders w ON w.product_id = p.id
-- JOIN operations o  ON o.work_order_id = w.id
-- WHERE o.op_start >= ?
--   AND o.op_end   <= ?
-- GROUP BY p.name
-- ORDER BY scrap_qty DESC, scrap_rate DESC;

-- B) By machine
-- SELECT m.name AS machine_name,
--        COALESCE(SUM(o.scrap_qty),0) AS scrap_qty,
--        COALESCE(SUM(o.good_qty + o.scrap_qty),0) AS total_qty,
--        CASE
--          WHEN COALESCE(SUM(o.good_qty + o.scrap_qty),0) = 0 THEN 0.0
--          ELSE CAST(SUM(o.scrap_qty) AS REAL) / SUM(o.good_qty + o.scrap_qty)
--        END AS scrap_rate
-- FROM machines m
-- JOIN operations o ON o.machine_id = m.id
-- WHERE o.op_start >= ?
--   AND o.op_end   <= ?
-- GROUP BY m.name
-- ORDER BY scrap_qty DESC, scrap_rate DESC;
